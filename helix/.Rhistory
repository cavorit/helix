install.packages("roxygen2")
install.packages("devtools")
library(helix)
library(helix)
library(roxygen2)
library("devtools", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library(helix)
library(helix)
library(helix)
library("tools", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library(helix)
load_all()
message("Version 0.1")
library(helix)
library(helix)
rm(list=ls())
RAW <- read.csv2("~/Dropbox (Cavorit)/Cavorit/Forschungsprojekte/Forschungsprojekt_CLIP02/Berechnungen/Inder/Datenmatrix_Inder_aktuell.xlsx")
RAW <- read.spss("~/Dropbox (Cavorit)/Cavorit/Forschungsprojekte/Forschungsprojekt_CLIP02/Berechnungen/Inder/Datenmatrix_Inder_DT-FB.sav")
library(foreign)
RAW <- read.spss("~/Dropbox (Cavorit)/Cavorit/Forschungsprojekte/Forschungsprojekt_CLIP02/Berechnungen/Inder/Datenmatrix_Inder_DT-FB.sav")
RAW <- read.spss("~/Dropbox (Cavorit)/Cavorit/Forschungsprojekte/Forschungsprojekt_CLIP02/Berechnungen/Inder/Datenmatrix_Inder_DT-FB.sav")
RAW <- read.spss("~/Dropbox (Cavorit)/Cavorit/Forschungsprojekte/Forschungsprojekt_CLIP02/Berechnungen/Inder/Datenmatrix_Inder_DT-FB.sav", use.value.labels = TRUE, to.data.frame = TRUE)
setwd("~/Dropbox (Cavorit)/Cavorit/Forschungsprojekte/Forschungsprojekt_CLIP02/Berechnungen/Inder/")
RAW <- read.spss("Datenmatrix_Inder_DT-FB.sav", use.value.labels = TRUE, to.data.frame = TRUE)
RAW <- read.spss("Datenmatrix_Inder_DT-FB.sav", use.value.labels = FALSE, to.data.frame = TRUE)
RAW
str(RAW)
class(RAW$VpnNr)
RAW
str(RAW)
INDER
INDER <- RAW
setwd("~/Desktop/Helix/helix
")
setwd("~/Desktop/Helix/helix")
INDER
sample(1:32, 4)
rm(list=ls())
library(foreign)
setwd("~/Dropbox (Cavorit)/Cavorit/Forschungsprojekte/Forschungsprojekt_CLIP02/Berechnungen/Inder/")
RAW <- read.spss("Datenmatrix_Inder_DT-FB.sav", use.value.labels = TRUE, to.data.frame = TRUE)
setwd("~/Desktop/Helix/helix")
RAW
INDER <- data.frame(
Vpn = paste0("VPn", RAW$VpnNr),
Name = RAW$Name,
Vorname = RAW$Vorname,
Mannschaft = RAW$Jahrgang,
DTr = RAW$DT_Richtige,
DTf = RAW$DT_Falsche,
DTa = RAW$DT_Ausgelassene,
DTz = RAW$DT_Zeit,
FB1z = RAW$FB_Speed,
FB1q = RAW$FB_Score,
FB2z = RAW$FB_Direkt_Speed,
FB2q = RAW$FB_Direkt_Score,
HXhinten = RAW$Helix_Richtige_hinten,
HXvorne = RAW$Helix_Richtige_Vorne,
HXdesign = RAW$Helix_Reihenfolge
)
INDER
str(INDER)
View(INDER)
View(INDER)
getwd()
setwd("./data/")
Inder <- INDER
save(list=INDER, file="Inder.Rda", compress=TRUE)
save(INDER, file="Inder.Rda", compress=TRUE)
library(devtools)
library(roxygen2)
library(helix)
stan.z <- c(-3, seq(-1.75, +1.75, length.out=8), 3)
# Second: get cumulative probabilities for these z values
stan.PR <- pnorm(stan.z)
# define a color ramp from blue to red (... or anything else ...)
c_ramp <- colorRamp(c("darkblue", "red"), space="Lab")
# draw the normal curve, without axes; reduce margins on left, top, and right
par(mar=c(2,0,0,0))
curve(dnorm(x,0,1), xlim=c(-3,3), ylim=c(-0.03, .45), xlab="", ylab="", axes=FALSE)
# Calculate polygons for each stanine region
# S.x = x values of polygon boundary points, S.y = y values
for (i in 1:(length(stan.z)-1)) {
S.x  <- c(stan.z[i], seq(stan.z[i], stan.z[i+1], 0.01), stan.z[i+1])
S.y  <- c(0, dnorm(seq(stan.z[i], stan.z[i+1], 0.01)), 0)
polygon(S.x,S.y, col=rgb(c_ramp(i/9), max=255))
}
# print stanine values in white
# font = 2 prints numbers in boldface
text(seq(-2,2, by=.5), 0.015, label=1:9, col="white", font=2)
# print cumulative probabilities in black below the curve
text(seq(-1.75,1.75, by=.5), -0.015, label=paste(round(stan.PR[-c(1, 10)], 2)*100, "%", sep=""), col="black", adj=.5, cex=.8)
text(0, -0.035, label="Percentage of sample <= this value", adj=0.5, cex=.8)
from.z <- -3
to.z <- qnorm(.025)
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col="red")
c_ramp <- colorRamp(c(rgb(200,100,0), rgb(13, 83, 97)), space="Lab")
c_ramp <- colorRamp(c(rgb(200,100,0)/255, rgb(13, 83, 97)/255), space="Lab")
c_ramp <- colorRamp(c((rgb(200,100,0)/255), (rgb(13, 83, 97)/255), space="Lab")
orange <- rgb(200, 100, 0, maxColorValue = 255)
orange <- rgb(200/255, 100/255, 0/255)
orange <- rgb(200/255, 100/255, 0/255, 1)
pantolgreen <- rgb(13/255, 83/255, 97/255)
c_ramp <- colorRamp(orange, pantolgreen, space="Lab")
orange
pantolgreen <- rgb(13/255, 83/255, 97/255)
c_ramp <- colorRamp(c(orange, pantolgreen), space="Lab")
# draw the normal curve, without axes; reduce margins on left, top, and right
par(mar=c(2,0,0,0))
curve(dnorm(x,0,1), xlim=c(-3,3), ylim=c(-0.03, .45), xlab="", ylab="", axes=FALSE)
# Calculate polygons for each stanine region
# S.x = x values of polygon boundary points, S.y = y values
for (i in 1:(length(stan.z)-1)) {
S.x  <- c(stan.z[i], seq(stan.z[i], stan.z[i+1], 0.01), stan.z[i+1])
S.y  <- c(0, dnorm(seq(stan.z[i], stan.z[i+1], 0.01)), 0)
polygon(S.x,S.y, col=rgb(c_ramp(i/9), max=255))
}
# print stanine values in white
# font = 2 prints numbers in boldface
text(seq(-2,2, by=.5), 0.015, label=1:9, col="white", font=2)
# print cumulative probabilities in black below the curve
text(seq(-1.75,1.75, by=.5), -0.015, label=paste(round(stan.PR[-c(1, 10)], 2)*100, "%", sep=""), col="black", adj=.5, cex=.8)
text(0, -0.035, label="Percentage of sample <= this value", adj=0.5, cex=.8)
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col="red")
staninePlot(){
}
# First: Calculate stanine breaks (on a z scale)
stan.z <- c(-3, seq(-1.75, +1.75, length.out=8), 3)
# Second: get cumulative probabilities for these z values
stan.PR <- pnorm(stan.z)
# define a color ramp from blue to red (... or anything else ...)
orange <- rgb(200/255, 100/255, 0/255, 1)
pantolgreen <- rgb(13/255, 83/255, 97/255)
c_ramp <- colorRamp(c(orange, pantolgreen), space="Lab")
# draw the normal curve, without axes; reduce margins on left, top, and right
par(mar=c(2,0,0,0))
curve(dnorm(x,0,1), xlim=c(-3,3), ylim=c(-0.03, .45), xlab="", ylab="", axes=FALSE)
# Calculate polygons for each stanine region
# S.x = x values of polygon boundary points, S.y = y values
for (i in 1:(length(stan.z)-1)) {
S.x  <- c(stan.z[i], seq(stan.z[i], stan.z[i+1], 0.01), stan.z[i+1])
S.y  <- c(0, dnorm(seq(stan.z[i], stan.z[i+1], 0.01)), 0)
polygon(S.x,S.y, col=rgb(c_ramp(i/9), max=255))
}
# print stanine values in white
# font = 2 prints numbers in boldface
text(seq(-2,2, by=.5), 0.015, label=1:9, col="white", font=2)
# print cumulative probabilities in black below the curve
text(seq(-1.75,1.75, by=.5), -0.015, label=paste(round(stan.PR[-c(1, 10)], 2)*100, "%", sep=""), col="black", adj=.5, cex=.8)
text(0, -0.035, label="Percentage of sample <= this value", adj=0.5, cex=.8)
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col="red")
# First: Calculate stanine breaks (on a z scale)
stan.z <- c(-3, seq(-1.75, +1.75, length.out=8), 3)
# Second: get cumulative probabilities for these z values
stan.PR <- pnorm(stan.z)
# define a color ramp from blue to red (... or anything else ...)
orange <- rgb(200/255, 100/255, 0/255, 1)
pantolgreen <- rgb(13/255, 83/255, 97/255)
c_ramp <- colorRamp(c(orange, pantolgreen), space="Lab")
# draw the normal curve, without axes; reduce margins on left, top, and right
par(mar=c(2,0,0,0))
curve(dnorm(x,0,1), xlim=c(-3,3), ylim=c(-0.03, .45), xlab="", ylab="", axes=FALSE)
# Calculate polygons for each stanine region
# S.x = x values of polygon boundary points, S.y = y values
for (i in 1:(length(stan.z)-1)) {
S.x  <- c(stan.z[i], seq(stan.z[i], stan.z[i+1], 0.01), stan.z[i+1])
S.y  <- c(0, dnorm(seq(stan.z[i], stan.z[i+1], 0.01)), 0)
polygon(S.x,S.y, col=rgb(c_ramp(i/9), max=255))
}
# print stanine values in white
# font = 2 prints numbers in boldface
text(seq(-2,2, by=.5), 0.015, label=1:9, col="white", font=2)
# print cumulative probabilities in black below the curve
text(seq(-1.75,1.75, by=.5), -0.015, label=paste(round(stan.PR[-c(1, 10)], 2)*100, "%", sep=""), col="black", adj=.5, cex=.8)
text(0, -0.035, label="Percentage of sample <= this value", adj=0.5, cex=.8)
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
# First: Calculate stanine breaks (on a z scale)
stan.z <- c(-3, seq(-1.75, +1.75, length.out=8), 3)
# Second: get cumulative probabilities for these z values
stan.PR <- pnorm(stan.z)
# define a color ramp from blue to red (... or anything else ...)
orange <- rgb(200/255, 100/255, 0/255, 1)
pantolgreen <- rgb(13/255, 83/255, 97/255)
c_ramp <- colorRamp(c(orange, pantolgreen), space="Lab")
# draw the normal curve, without axes; reduce margins on left, top, and right
par(mar=c(2,0,0,0))
curve(dnorm(x,0,1), xlim=c(-3,3), ylim=c(-0.03, .45), xlab="", ylab="", axes=FALSE)
# Calculate polygons for each stanine region
# S.x = x values of polygon boundary points, S.y = y values
for (i in 1:(length(stan.z)-1)) {
S.x  <- c(stan.z[i], seq(stan.z[i], stan.z[i+1], 0.01), stan.z[i+1])
S.y  <- c(0, dnorm(seq(stan.z[i], stan.z[i+1], 0.01)), 0)
polygon(S.x,S.y, col=rgb(c_ramp(i/9), max=255))
}
# print stanine values in white
# font = 2 prints numbers in boldface
text(seq(-2,2, by=.5), 0.015, label=1:9, col="white", font=2)
# print cumulative probabilities in black below the curve
text(seq(-1.75,1.75, by=.5), -0.015, label=paste(round(stan.PR[-c(1, 10)], 2)*100, "%", sep=""), col="black", adj=.5, cex=.8)
text(0, -0.035, label="Percentage of sample <= this value", adj=0.5, cex=.8)
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col="red")
polygon(S.x,S.y, col=rgb(200/255, 100/255, 0/255, 1))
polygon(S.x,S.y, col=rgb(200/255, 100/255, 0/255, .5))
polygon(S.x,S.y, col=rgb(200/255, 100/255, 0/255, alpha = .5))
library(helix)
S.x  <- c(to.z, seq(to.z, 3, 0.01), 3)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col=rgb(200/255, 100/255, 0/255, alpha = .5))
S.x  <- c(to.z, seq(to.z, 3, 0.01), 3)
S.y  <- c(0, dnorm(seq(to.z, 3, 0.01)), 0)
polygon(S.x,S.y, col=rgb(200/255, 100/255, 0/255, alpha = .5))
polygon(S.x,S.y, col=rgb(13/255, 87/255, 93/255, alpha = .5))
staninePlotDichotom <- function(trennQuote, alphaKanal=1){
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
# Links
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col=rgb(200/255, 100/255, 0/255, alpha = alphaKanal))
# Rechts
S.x  <- c(to.z, seq(to.z, 3, 0.01), 3)
S.y  <- c(0, dnorm(seq(to.z, 3, 0.01)), 0)
polygon(S.x,S.y, col=rgb(13/255, 87/255, 93/255, alpha = alphaKanal))
}
staninePlotDichotom(splitQuote = .3)
staninePlotDichotom <- function(splitQuote, alphaKanal=1){
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
# Links
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col=rgb(200/255, 100/255, 0/255, alpha = alphaKanal))
# Rechts
S.x  <- c(to.z, seq(to.z, 3, 0.01), 3)
S.y  <- c(0, dnorm(seq(to.z, 3, 0.01)), 0)
polygon(S.x,S.y, col=rgb(13/255, 87/255, 93/255, alpha = alphaKanal))
}
staninePlotDichotom(splitQuote = .3)
staninePlotDichotom <- function(splitQuote, alphaKanal=1){
orange <- rgb(200/255, 100/255, 0/255, alpha = alphaKanal)
pantolgreen <- rgb(13/255, 87/255, 93/255, alpha = alphaKanal)
FarbeLinks <- orange
FarbeRechts <- pantolgreen
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
# Links
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col=FarbeLinks)
# Rechts
S.x  <- c(to.z, seq(to.z, 3, 0.01), 3)
S.y  <- c(0, dnorm(seq(to.z, 3, 0.01)), 0)
polygon(S.x,S.y, col=FarbeRechts)
}
staninePlotDichotom(splitQuote = .3)
staninePlotDichotom <- function(splitQuote, alphaKanal=1){
orange <- rgb(200/255, 100/255, 0/255, alpha = alphaKanal)
pantolgreen <- rgb(13/255, 87/255, 93/255, alpha = alphaKanal)
FarbeLinks <- orange
FarbeRechts <- red
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
# Links
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col=FarbeLinks)
# Rechts
S.x  <- c(to.z, seq(to.z, 3, 0.01), 3)
S.y  <- c(0, dnorm(seq(to.z, 3, 0.01)), 0)
polygon(S.x,S.y, col=FarbeRechts)
}
staninePlotDichotom(splitQuote = .3)
staninePlotDichotom <- function(splitQuote, alphaKanal=1){
orange <- rgb(200/255, 100/255, 0/255, alpha = alphaKanal)
pantolgreen <- rgb(13/255, 87/255, 93/255, alpha = alphaKanal)
FarbeLinks <- orange
FarbeRechts <- "red"
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
# Links
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col=FarbeLinks)
# Rechts
S.x  <- c(to.z, seq(to.z, 3, 0.01), 3)
S.y  <- c(0, dnorm(seq(to.z, 3, 0.01)), 0)
polygon(S.x,S.y, col=FarbeRechts)
}
staninePlotDichotom(splitQuote = .3)
staninePlotDichotom <- function(splitQuote, alphaKanal=1){
orange <- rgb(200/255, 100/255, 0/255, alpha = alphaKanal)
pantolgreen <- rgb(13/255, 87/255, 93/255, alpha = alphaKanal)
FarbeLinks <- orange
FarbeRechts <- pantolgreen
# draw the normal curve
curve(dnorm(x,0,1), xlim=c(-3,3), main="Normal density")
# define shaded region
from.z <- -3
to.z <- qnorm(.025)
# Links
S.x  <- c(from.z, seq(from.z, to.z, 0.01), to.z)
S.y  <- c(0, dnorm(seq(from.z, to.z, 0.01)), 0)
polygon(S.x,S.y, col=FarbeLinks)
# Rechts
S.x  <- c(to.z, seq(to.z, 3, 0.01), 3)
S.y  <- c(0, dnorm(seq(to.z, 3, 0.01)), 0)
polygon(S.x,S.y, col=FarbeRechts)
}
staninePlotDichotom(splitQuote = .3)
library(helix)
